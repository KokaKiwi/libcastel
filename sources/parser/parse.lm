%token_prefix     { lexer::lexer::T_ }
%token_type       { lexer::Lexeme *  }
%token_destructor { delete $$;       }

%left Add Substract.
%left Multiply Divide Modulo.

%nonassoc Spaces Newline.
%nonassoc Indent Dedent.

%include {

    #include <iostream>
    #include <cassert>

    #include "p9/ast/expr/Binary.hh"
    #include "p9/ast/expr/Number.hh"
    #include "p9/ast/Token.hh"
    #include "p9/lexer/Lexeme.hh"
    #include "p9/lexer/Type.hh"

    using namespace p9;

    static bool p9parserIsValid;
    static ast::Token * p9parserRootToken;

}

%syntax_error {

    p9parserIsValid = false;

}

%type program { ast::Token * }
program ::= expression(U). { p9parserRootToken = U; }

%type expression { ast::Expression * }
expression(A) ::= binaryoperator(U). { A = U; }
expression(A) ::= numberliteral(U).  { A = U; }

%type binaryoperator { ast::expr::Binary * }
binaryoperator(A) ::= expression(U) Add       expression(V). { A = new ast::expr::Binary( lexer::T_Add,       U, V ); }
binaryoperator(A) ::= expression(U) Substract expression(V). { A = new ast::expr::Binary( lexer::T_Substract, U, V ); }
binaryoperator(A) ::= expression(U) Multiply  expression(V). { A = new ast::expr::Binary( lexer::T_Multiply,  U, V ); }
binaryoperator(A) ::= expression(U) Divide    expression(V). { A = new ast::expr::Binary( lexer::T_Divide,    U, V ); }
binaryoperator(A) ::= expression(U) Modulo    expression(V). { A = new ast::expr::Binary( lexer::T_Modulo,    U, V ); }

%type numberliteral { ast::expr::Number * }
numberliteral(A) ::= Number(U). { A = new ast::expr::Number(*U); }
