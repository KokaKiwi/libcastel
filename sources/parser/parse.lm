%token_type {ast::Token *}
%token_prefix T_

%nonassoc Spaces Newline.

%include {
	
  #include <iostream>
  #include <cassert>
  
  #include "p9/ast/Token.hh"
  #include "p9/ast/StatementList.hh"
  #include "p9/ast/Statement.hh"
  #include "p9/ast/ImportStatement.hh"
  #include "p9/ast/FromClause.hh"
  #include "p9/ast/AsClause.hh"
  #include "p9/ast/Identifier.hh"
  
  using namespace p9;
  
  static bool p9parserIsValid;
  static ast::Token * p9parserRootToken;
  
}

%syntax_error {
	
  p9parserIsValid = false;
  
}

program ::= statementlist(A). { p9parserRootToken = A; }

statementlist(A) ::= statement(B) statementlist(C). { A = new ast::StatementList( ); static_cast< ast::StatementList & >( *A ).merge( static_cast< ast::Statement * >( B ) ).merge( static_cast< ast::StatementList * >( C ) ); }
statementlist(A) ::= .                              { A = new ast::StatementList( ); }

statement(A) ::= declarationstatement. { A = 0; }
statement(A) ::= importstatement(B).   { A = B; }
statement(A) ::= returnstatement.      { A = 0; }
statement(A) ::= expressionstatement.  { A = 0; }
statement(A) ::= emptystatement.       { A = 0; }

block ::= LBrace statementlist RBrace.

declarationstatement ::= variabledeclaration.
declarationstatement ::= functiondeclaration.
declarationstatement ::= classdeclaration.

importstatement(A) ::= fromclause(B) Import Identifier(C) asclause(D) Semicolon. { static_cast< ast::ImportStatement & >( *( A = new ast::ImportStatement( ) ) ).setFromClause( static_cast< ast::FromClause * >( B ) ).setLabel( static_cast< ast::Identifier * >( C ) ).setAsClause( static_cast< ast::AsClause * >( D ) ); }
importstatement(A) ::= fromclause(B) Import Identifier(C) Semicolon.             { static_cast< ast::ImportStatement & >( *( A = new ast::ImportStatement( ) ) ).setFromClause( static_cast< ast::FromClause * >( B ) ).setLabel( static_cast< ast::Identifier * >( C ) ); }
importstatement(A) ::= Import Identifier(B) asclause(C) Semicolon.               { static_cast< ast::ImportStatement & >( *( A = new ast::ImportStatement( ) ) ).setLabel( static_cast< ast::Identifier * >( B ) ).setAsClause( static_cast< ast::AsClause * >( C ) ); }
importstatement(A) ::= Import Identifier(B) Semicolon.                           { static_cast< ast::ImportStatement & >( *( A = new ast::ImportStatement( ) ) ).setLabel( static_cast< ast::Identifier * >( B ) ); }

fromclause ::= From importpath.

importpath ::= Identifier importpathnext.

importpathnext ::= Dot importpath.
importpathnext ::= .

asclause ::= As Identifier.

returnstatement ::= Return Semicolon.
returnstatement ::= Return expression Semicolon.

expressionstatement ::= expression Semicolon.

emptystatement ::= Semicolon.

variabledeclaration ::= type Identifier Semicolon.
variabledeclaration ::= type Identifier Assign expression Semicolon.

type ::= Mixed.
type ::= Identifier.

functiondeclaration ::= Function Identifier declarationarguments block.
functiondeclaration ::= Function Identifier declarationarguments Colon type block.

declarationarguments ::= LParenthesis RParenthesis.
declarationarguments ::= LParenthesis Void RParenthesis.
declarationarguments ::= LParenthesis argumentlist RParenthesis.

argumentlist ::= argument.
argumentlist ::= argumentlist Comma argument.

argument ::= Identifier Colon type.

classdeclaration ::= Class Identifier classblock.

classblock ::= LBrace memberdeclaration RBrace.

memberdeclaration ::= membervariabledeclaration memberdeclaration.
memberdeclaration ::= memberfunctiondeclaration memberdeclaration.
memberdeclaration ::= .

membervariabledeclaration ::= visibility variabledeclaration.
memberfunctiondeclaration ::= visibility functiondeclaration.

visibility ::= Public.
visibility ::= Private.

expression ::= expressionlvl13.

expressionlvl13 ::= expressionlvl12.
expressionlvl13 ::= expressionlvl12 Assign expressionlvl13.
expressionlvl13 ::= expressionlvl12 AssignNumericAddition expressionlvl13.
expressionlvl13 ::= expressionlvl12 AssignNumericSubstraction expressionlvl13.
expressionlvl13 ::= expressionlvl12 AssignNumericMultiplication expressionlvl13.
expressionlvl13 ::= expressionlvl12 AssignNumericDivision expressionlvl13.
expressionlvl13 ::= expressionlvl12 AssignNumericModulo expressionlvl13.
expressionlvl13 ::= expressionlvl12 AssignBinaryAnd expressionlvl13.
expressionlvl13 ::= expressionlvl12 AssignBinaryOr expressionlvl13.
expressionlvl13 ::= expressionlvl12 AssignBinaryXor expressionlvl13.
expressionlvl13 ::= expressionlvl12 AssignBinaryLShift expressionlvl13.
expressionlvl13 ::= expressionlvl12 AssignBinaryRShift expressionlvl13.

expressionlvl12 ::= expressionlvl11.
expressionlvl12 ::= expressionlvl11 LogicalOr expressionlvl12.

expressionlvl11 ::= expressionlvl10.
expressionlvl11 ::= expressionlvl10 LogicalAnd expressionlvl11.

expressionlvl10 ::= expressionlvl09.
expressionlvl10 ::= expressionlvl09 BinaryOr expressionlvl10.

expressionlvl09 ::= expressionlvl08.
expressionlvl09 ::= expressionlvl08 BinaryXor expressionlvl09.

expressionlvl08 ::= expressionlvl07.
expressionlvl08 ::= expressionlvl07 BinaryAnd expressionlvl08.

expressionlvl07 ::= expressionlvl06.
expressionlvl07 ::= expressionlvl06 RelationalEqual expressionlvl07.
expressionlvl07 ::= expressionlvl06 RelationalDifferent expressionlvl07.

expressionlvl06 ::= expressionlvl05.
expressionlvl06 ::= expressionlvl05 RelationalLesser expressionlvl06.
expressionlvl06 ::= expressionlvl05 RelationalGreater expressionlvl06.
expressionlvl06 ::= expressionlvl05 RelationalLesserOrEqual expressionlvl06.
expressionlvl06 ::= expressionlvl05 RelationalGreaterOrEqual expressionlvl06.

expressionlvl05 ::= expressionlvl04.
expressionlvl05 ::= expressionlvl04 BinaryLShift expressionlvl05.
expressionlvl05 ::= expressionlvl04 BinaryRShift expressionlvl05.

expressionlvl04 ::= expressionlvl03.
expressionlvl04 ::= expressionlvl03 NumericAddition expressionlvl04.
expressionlvl04 ::= expressionlvl03 NumericSubstraction expressionlvl04.

expressionlvl03 ::= expressionlvl02.
expressionlvl03 ::= expressionlvl02 NumericMultiplication expressionlvl03.
expressionlvl03 ::= expressionlvl02 NumericDivision expressionlvl03.
expressionlvl03 ::= expressionlvl02 NumericModulo expressionlvl03.

expressionlvl02 ::= expressionlvl01.
expressionlvl02 ::= Increment expressionlvl01.
expressionlvl02 ::= Decrement expressionlvl01.
expressionlvl02 ::= NumericAddition expressionlvl01.
expressionlvl02 ::= NumericSubstraction expressionlvl01.
expressionlvl02 ::= BinaryNot expressionlvl01.
expressionlvl02 ::= LogicalNot expressionlvl01.

expressionlvl01 ::= expressionlvl00.
expressionlvl01 ::= expressionlvl00 Increment.
expressionlvl01 ::= expressionlvl00 Decrement.

expressionlvl00 ::= selectorexpression.
expressionlvl00 ::= callexpression.
expressionlvl00 ::= newexpression.

selectorexpression ::= primaryexpression.
selectorexpression ::= selectorexpression Dot Identifier.
selectorexpression ::= selectorexpression LBracket expression RBracket.

callexpression ::= selectorexpression callarguments.

newexpression ::= New selectorexpression callarguments.

callarguments ::= LParenthesis RParenthesis.
callarguments ::= LParenthesis expressionlist RParenthesis.

expressionlist ::= expression.
expressionlist ::= expressionlist Comma expression.

primaryexpression ::= literal.
primaryexpression ::= This.
primaryexpression ::= Super.
primaryexpression ::= Identifier.
primaryexpression ::= LParenthesis expression RParenthesis.

literal ::= numberliteral.
literal ::= stringliteral.
literal ::= arrayliteral.
literal ::= objectliteral.
literal ::= functionliteral.
literal ::= classliteral.

numberliteral ::= Number.

stringliteral ::= String.

arrayliteral ::= LBracket RBracket.
arrayliteral ::= LBracket expressionlist RBracket.

objectliteral ::= LBrace RBrace.
objectliteral ::= LBrace pairlist RBrace.

pairlist ::= pair.
pairlist ::= pairlist Comma pair.

pair ::= Identifier Colon expression.

functionliteral ::= Function declarationarguments block.
functionliteral ::= Function declarationarguments Colon type block.

classliteral ::= Class classblock.
