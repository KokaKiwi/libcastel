%token_prefix CASTEL_LEXER_MANGLEDLEXEMESTYPES_
%token_type   { lexer::Lexeme *     }

%left Incrementation Decrementation LParenthesis LBracket.
%left PositiveAddition NegativeSubstraction.
%left Multiplication Division Modulo.
%left Assignment AdditionAssignment SubstractionAssignment MultiplicationAssignment DivisionAssignment ModuloAssignment.

%nonassoc Spaces Newline.
%nonassoc Indent Dedent.

%include {

    #include <cassert>

    #include "castel/ast/expr/Boolean.hh"
    #include "castel/ast/expr/Binary.hh"
    #include "castel/ast/expr/Function.hh"
    #include "castel/ast/expr/Multary.hh"
    #include "castel/ast/expr/Null.hh"
    #include "castel/ast/expr/Number.hh"
    #include "castel/ast/expr/Unary.hh"
    #include "castel/ast/expr/Undefined.hh"
    #include "castel/ast/expr/Variable.hh"
    #include "castel/ast/stmt/decl/Variables.hh"
    #include "castel/ast/stmt/Expression.hh"
    #include "castel/ast/stmt/If.hh"
    #include "castel/ast/stmt/Return.hh"
    #include "castel/ast/Expression.hh"
    #include "castel/ast/Statement.hh"

    using namespace castel;

    static bool castelparserIsValid;
    static ast::Statement * castelparserRootStatement;

}

%syntax_error {
    castelparserIsValid = false;
}

%type program { ast::Statement * }
program ::= statementlist(U). { castelparserRootStatement = U; }

    %type statementlist { ast::Statement * }
    statementlist(A) ::= emptystatementlist statementlistiterator(U). { A = U; }

    %type statementblock { ast::Statement * }
    statementblock(A) ::= Indent statementlist(U) Dedent. { A = U; }

    %type statementlistiterator { ast::Statement * }
    statementlistiterator(A) ::= . { A = nullptr; }
    statementlistiterator(A) ::= statement(U) emptystatementlist statementlistiterator(V). { A = U; U->next( V ); }

        emptystatementlist ::= Newline emptystatementlist.
        emptystatementlist ::= .

    %type statement { ast::Statement * }
    statement(A) ::= expressionstatement(U). { A = U; }
    statement(A) ::= returnstatement(U). { A = U; }
    statement(A) ::= variabledeclarationstatement(U). { A = U; }
    statement(A) ::= ifstatement(U). { A = U; }

        %type expressionstatement { ast::stmt::Expression * }
        expressionstatement(A) ::= expression(U) Newline. { A = new ast::stmt::Expression( U ); }

        %type ifstatement { ast::stmt::If * }
        ifstatement(A) ::= If expression(U) Colon statement(V). { A = new ast::stmt::If( U, V ); }
        ifstatement(A) ::= If expression(U) Colon statementblock(V) Else Colon statementblock(W). { A = new ast::stmt::If( U, V, W ); }
        ifstatement(A) ::= If expression(U) Colon statementblock(V). { A = new ast::stmt::If( U, V );    }

        %type returnstatement { ast::stmt::Return * }
        returnstatement(A) ::= Return Newline. { A = new ast::stmt::Return( ); }
        returnstatement(A) ::= Return expression(U) Newline. { A = new ast::stmt::Return( U ); }

        %type variabledeclarationstatement { ast::stmt::decl::Variables * }
        variabledeclarationstatement(A) ::= Var variabledeclarations(U) Newline. { A = new ast::stmt::decl::Variables( U ); }

        %type variabledeclarations { ast::stmt::decl::Variables::Variable * }
        variabledeclarations(A) ::= variabledeclaration(U) Comma variabledeclarations(V). { A = U; U->next( V ); }
        variabledeclarations(A) ::= variabledeclaration(U). { A = U; }

        %type variabledeclaration { ast::stmt::decl::Variables::Variable * }
        variabledeclaration(A) ::= Identifier(U). { A = new ast::stmt::decl::Variables::Variable( * U ); }
        variabledeclaration(A) ::= Identifier(U) Assignment expression(V). { A = new ast::stmt::decl::Variables::Variable( * U, V ); }

%type expression { ast::Expression * }
expression(A) ::= assignmentexpression(U). { A = U; }

    %type assignmentexpression { ast::Expression * }
    assignmentexpression(A) ::= conditionalexpression(U). { A = U; }
    assignmentexpression(A) ::= assignmentexpression(U) assignmentoperator(V) conditionalexpression(W). { A = new ast::expr::Binary( V, U, W ); }

        %type assignmentoperator { ast::expr::Binary::Operator }
        assignmentoperator(A) ::= Assignment. { A = ast::expr::Binary::Operator::Assignment; }
        assignmentoperator(A) ::= AdditionAssignment. { A = ast::expr::Binary::Operator::AdditionAssignment; }
        assignmentoperator(A) ::= SubstractionAssignment. { A = ast::expr::Binary::Operator::SubstractionAssignment; }
        assignmentoperator(A) ::= MultiplicationAssignment. { A = ast::expr::Binary::Operator::MultiplicationAssignment; }
        assignmentoperator(A) ::= DivisionAssignment. { A = ast::expr::Binary::Operator::DivisionAssignment; }
        assignmentoperator(A) ::= ModuloAssignment. { A = ast::expr::Binary::Operator::ModuloAssignment; }

        %type conditionalexpression { ast::Expression * }
        conditionalexpression(A) ::= binaryexpression(U). { A = U; }
        conditionalexpression(A) ::= conditionalexpression(U) conditionaloperator(V) binaryexpression(W). { A = new ast::expr::Binary( V, U, W ); }

            %type conditionaloperator { ast::expr::Binary::Operator }
            conditionaloperator(A) ::= And. { A = ast::expr::Binary::Operator::And; }
            conditionaloperator(A) ::= Or. { A = ast::expr::Binary::Operator::Or; }

            %type binaryexpression { ast::Expression * }
            binaryexpression(A) ::= comparisonexpression(U). { A = U; }

                %type comparisonexpression { ast::Expression * }
                comparisonexpression(A) ::= shiftexpression(U). { A = U; }
                comparisonexpression(A) ::= comparisonexpression(U) comparisonoperator(V) shiftexpression(W). { A = new ast::expr::Binary( V, U, W ); }

                    %type comparisonoperator { ast::expr::Binary::Operator }
                    comparisonoperator(A) ::= Lesser. { A = ast::expr::Binary::Operator::Lesser; }
                    comparisonoperator(A) ::= Greater. { A = ast::expr::Binary::Operator::Greater; }
                    comparisonoperator(A) ::= LesserOrEqual. { A = ast::expr::Binary::Operator::LesserOrEqual; }
                    comparisonoperator(A) ::= GreaterOrEqual. { A = ast::expr::Binary::Operator::GreaterOrEqual; }
                    comparisonoperator(A) ::= Equal. { A = ast::expr::Binary::Operator::Equal; }
                    comparisonoperator(A) ::= NotEqual. { A = ast::expr::Binary::Operator::NotEqual; }

                    %type shiftexpression { ast::Expression * }
                    shiftexpression(A) ::= additiveexpression(U). { A = U; }

                        %type additiveexpression { ast::Expression * }
                        additiveexpression(A) ::= multiplicativeexpression(U). { A = U; }
                        additiveexpression(A) ::= additiveexpression(U) additiveoperator(V) multiplicativeexpression(W). { A = new ast::expr::Binary( V, U, W ); }

                            %type additiveoperator { ast::expr::Binary::Operator }
                            additiveoperator(A) ::= PositiveAddition. { A = ast::expr::Binary::Operator::Addition; }
                            additiveoperator(A) ::= NegativeSubstraction. { A = ast::expr::Binary::Operator::Substraction; }

                            %type multiplicativeexpression { ast::Expression * }
                            multiplicativeexpression(A) ::= prefixexpression(U). { A = U; }
                            multiplicativeexpression(A) ::= multiplicativeexpression(U) multiplicativeoperator(V) prefixexpression(W). { A = new ast::expr::Binary( V, U, W ); }

                                %type multiplicativeoperator { ast::expr::Binary::Operator }
                                multiplicativeoperator(A) ::= Multiplication. { A = ast::expr::Binary::Operator::Multiplication; }
                                multiplicativeoperator(A) ::= Division. { A = ast::expr::Binary::Operator::Division; }
                                multiplicativeoperator(A) ::= Modulo. { A = ast::expr::Binary::Operator::Modulo; }

                                    %type prefixexpression { ast::Expression * }
                                    prefixexpression(A) ::= postfixexpression(U). { A = U; }
                                    prefixexpression(A) ::= prefixoperator(U) prefixexpression(V). { A = new ast::expr::Unary( U, V ); }

                                        %type prefixoperator { ast::expr::Unary::Operator }
                                        prefixoperator(A) ::= PositiveAddition. { A = ast::expr::Unary::Operator::Positive; }
                                        prefixoperator(A) ::= NegativeSubstraction. { A = ast::expr::Unary::Operator::Negative; }
                                        prefixoperator(A) ::= Incrementation. { A = ast::expr::Unary::Operator::PreIncrementation; }
                                        prefixoperator(A) ::= Decrementation. { A = ast::expr::Unary::Operator::PreDecrementation; }

                                        %type postfixexpression { ast::Expression * }
                                        postfixexpression(A) ::= primaryexpression(U). { A = U; }
                                        postfixexpression(A) ::= postfixexpression(U) postfixoperator(V). { A = new ast::expr::Unary( V, U ); }
                                        postfixexpression(A) ::= postfixexpression(U) callexpression(V). { A = new ast::expr::Multary( ast::expr::Multary::Operator::Call, U ); U->next( V ); }
                                        postfixexpression(A) ::= postfixexpression(U) subscriptexpression(V). { A = new ast::expr::Multary( ast::expr::Multary::Operator::Subscript, U ); U->next( V ); }

                                            %type postfixoperator { ast::expr::Unary::Operator }
                                            postfixoperator(A) ::= Incrementation. { A = ast::expr::Unary::Operator::PostIncrementation; }
                                            postfixoperator(A) ::= Decrementation. { A = ast::expr::Unary::Operator::PostDecrementation; }

                                            %type callexpression { ast::Expression * }
                                            callexpression(A) ::= LParenthesis expressionlist(U) RParenthesis. { A = U; }

                                            %type subscriptexpression { ast::Expression * }
                                            subscriptexpression(A) ::= LBracket expressionlist(U) RBracket. { A = U; }

                                                %type expressionlist { ast::Expression * }
                                                expressionlist(A) ::= . { A = nullptr; }
                                                expressionlist(A) ::= expressioniterator(U). { A = U; }

                                                    %type expressioniterator { ast::Expression * }
                                                    expressioniterator(A) ::= expression(U). { A = U; }
                                                    expressioniterator(A) ::= expression(U) Comma expressioniterator(V). { A = U; A->next( V ); }

                                            %type primaryexpression { ast::Expression * }
                                            primaryexpression(A) ::= Identifier(U). { A = new ast::expr::Variable( * U ); }
                                            primaryexpression(A) ::= literal(U). { A = U; }
                                            primaryexpression(A) ::= LParenthesis expression(U) RParenthesis. { A = U; }

                                                %type literal { ast::Expression * }
                                                literal(A) ::= nullliteral(U). { A = U; }
                                                literal(A) ::= undefinedliteral(U). { A = U; }
                                                literal(A) ::= booleanliteral(U). { A = U; }
                                                literal(A) ::= numberliteral(U). { A = U; }
                                                literal(A) ::= functionliteral(U). { A = U; }

                                                    %type nullliteral { ast::expr::Null * }
                                                    nullliteral(A) ::= Null. { A = new ast::expr::Null( ); }

                                                    %type undefinedliteral { ast::expr::Undefined * }
                                                    undefinedliteral(A) ::= Undefined. { A = new ast::expr::Undefined( ); }

                                                    %type booleanliteral { ast::expr::Boolean * }
                                                    booleanliteral(A) ::= True. { A = new ast::expr::Boolean( true ); }
                                                    booleanliteral(A) ::= False. { A = new ast::expr::Boolean( false ); }

                                                    %type numberliteral { ast::expr::Number * }
                                                    numberliteral(A) ::= Number(U). { A = new ast::expr::Number( * U ); }

                                                    %type functionliteral { ast::expr::Function * }
                                                    functionliteral(A) ::= LParenthesis Function parameterlist(U) Colon statementblock(V) RParenthesis. { A = new ast::expr::Function( U, V ); }

                                                        %type parameterlist { ast::expr::Function::Parameter * }
                                                        parameterlist(A) ::= . { A = nullptr; }
                                                        parameterlist(A) ::= parameterlistiterator(U). { A = U; }

                                                            %type parameterlistiterator { ast::expr::Function::Parameter * }
                                                            parameterlistiterator(A) ::= parameter(U). { A = U; }
                                                            parameterlistiterator(A) ::= parameter(U) Comma parameterlistiterator(V). { A = U; A->next( V ); }

                                                                %type parameter { ast::expr::Function::Parameter * }
                                                                parameter(A) ::= Identifier(U). { A = new ast::expr::Function::Parameter( * U ); }
